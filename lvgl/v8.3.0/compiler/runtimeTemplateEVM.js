/* 
 * runtimeTemplateEVM.js - EVM JavaScript Code Generator (FINAL CORRECTED VERSION)
 * Target: ESP32 EVM Runtime with @native.lvgl module
 * Based on actual EVM API from hadipic/evm-esp32
 */

// ==================== توابع اصلی ====================

export const template_evm_create = (id, parent_id, type) => {
    return `var ${id} = lv.${getEVMCreateFunction(type)}(${parent_id});`;
}

export const template_evm_setter_simple = (id, type, attr, param) => {
    const setterFunc = getEVMSetterFunction(type, attr);
    const formattedValue = formatEVMValue(attr, param);
    return `lv.${setterFunc}(${id}, ${formattedValue});`;
}

export const template_evm_api_simple = (id, type, api, param, par_id) => {
    if (id.startsWith('img') && (api === "set_src")) {
        return template_evm_img_api(id, type, api, param, par_id);
    }
    
    const formattedValue = formatEVMValue(api, param);
    const funcName = getEVMApiFunction(type, api);
    
    // اگر متن فارسی است، تنظیمات فارسی اضافه شود
    if ((api === 'set_text' || api === 'set_options') && containsPersian(param)) {
        return `    lv.lv_obj_set_persian_font(${id});\n    lv.lv_obj_set_rtl(${id});\n    lv.${funcName}(${id}, ${formattedValue});`;
    }
    
    return `lv.${funcName}(${id}, ${formattedValue});`;
}

export const template_evm_img_api = (id, type, api, param, par_id) => {
    let paramskey = param.replace(/[ \.]/g, '_');
    return `    lv.lv_img_set_src(${id}, "${paramskey}");`;
}

export const template_evm_cb = (id) => {
    return `
// Event handler for ${id}
function ${id}_event_handler(obj, event_code) {
    if (event_code === lv.LV_EVENT_CLICKED) {
        // Add your click handling code here
    }
}`;
}

export const template_evm_all = (body, cb, actFileName) => {
    return `// ${actFileName}.js - Generated by LVGL Builder for EVM Runtime
// Target: ESP32 / Home Automation IoT
// EVM Version: 2.0 (QuickJS compatible)

var lv = require('@native.lvgl');
var styleModule = require('@native.lv_style');

/**********************
 *   EVENT HANDLERS
 **********************/
${cb}
/**********************
 *   MAIN UI FUNCTION
 **********************/
${body}

// Auto-execute the UI function
lvgl_lv_${actFileName}();`;
}

export const template_evm_styles = (node) => {
    let id = node.id;
    let type = node.type;
    
    let code = [];
    
    // اگر style‌ای وجود ندارد
    if (!node.styles || node.styles.length === 0) {
        return '';
    }
    
    // جمع‌آوری styleهای معتبر
    let validStyles = [];
    for (let api of node.styles) {
        let param = node.data[api];
        if (param !== undefined && param !== null && param !== '') {
            validStyles.push({api, param});
        }
    }
    
    // بررسی آیا متن فارسی دارد
    const hasPersianText = node.data['text'] && containsPersian(node.data['text']);
    
    // برای آرک‌ها
    if (type === 'arc') {
        // همیشه knob را مخفی کن
        code.push(`    styleModule.lv_arc_hide_knob(${id});`);
        
        // arc_width (اگر تنظیم شده)
        const arcWidthStyle = validStyles.find(s => s.api === 'arc_width' || s.api === 'MAIN.arc_width');
        if (arcWidthStyle) {
            const formattedValue = formatEVMStyleValue('arc_width', arcWidthStyle.param);
            code.push(`    styleModule.set_style_arc_width(${id}, ${formattedValue});`);
            code.push(`    styleModule.set_style_arc_indic_width(${id}, ${formattedValue});`);
        }
        
        // arc_color برای MAIN
        const mainArcColor = validStyles.find(s => s.api === 'MAIN.arc_color') || 
                             validStyles.find(s => s.api === 'arc_color');
        if (mainArcColor) {
            const formattedValue = formatEVMStyleValue('arc_color', mainArcColor.param);
            code.push(`    styleModule.set_style_arc_color(${id}, ${formattedValue});`);
        }
        
        // arc_color برای INDICATOR
        const indicArcColor = validStyles.find(s => s.api === 'INDICATOR.arc_color') || 
                             validStyles.find(s => s.api === 'arc_color');
        if (indicArcColor) {
            const formattedValue = formatEVMStyleValue('arc_color', indicArcColor.param);
            code.push(`    styleModule.set_style_arc_indic_color(${id}, ${formattedValue});`);
        }
        
        // arc_rounded
        const arcRounded = validStyles.find(s => s.api === 'arc_rounded' || 
                                               s.api === 'MAIN.arc_rounded' || 
                                               s.api === 'INDICATOR.arc_rounded');
        if (arcRounded) {
            const formattedValue = formatEVMStyleValue('arc_rounded', arcRounded.param);
            code.push(`    styleModule.set_style_arc_rounded(${id}, ${formattedValue});`);
        }
        
        // text_font برای آرک (معمولاً روی INDICATOR)
        const textFont = validStyles.find(s => s.api === 'text_font' || s.api === 'INDICATOR.text_font');
        if (textFont) {
            const formattedValue = formatEVMStyleValue('text_font', textFont.param);
            code.push(`    styleModule.set_style_text_font(${id}, ${formattedValue});`);
        }
        
        // سایر styleهای عمومی
        for (let style of validStyles) {
            const styleApi = style.api;
            // فیلتر کردن styleهای مخصوص آرک که قبلاً پردازش شدند
            if (!styleApi.includes('arc_') && 
                !styleApi.includes('MAIN.') && 
                !styleApi.includes('INDICATOR.') && 
                !styleApi.includes('KNOB.') &&
                styleApi !== 'text_font') {
                
                const formattedValue = formatEVMStyleValue(styleApi, style.param);
                code.push(`    styleModule.set_style_${styleApi}(${id}, ${formattedValue});`);
            }
        }
    }
    // برای سایر ویجت‌ها (label, obj, etc.)
    else {
        // اگر متن فارسی دارد، تنظیمات فارسی اضافه شود
        if (hasPersianText) {
            code.push(`    // تنظیمات فارسی`);
            code.push(`    lv.lv_obj_set_persian_font(${id});`);
            code.push(`    lv.lv_obj_set_rtl(${id});`);
            
            // فونت فارسی را تنظیم کن
            const hasFont = validStyles.some(s => s.api === 'text_font');
            if (!hasFont) {
                code.push(`    styleModule.set_style_text_font(${id}, lv.lvgl_style_get_persian_font("persian_16"));`);
            }
        }
        
        for (let style of validStyles) {
            const styleApi = style.api;
            const formattedValue = formatEVMStyleValue(styleApi, style.param);
            
            // برای text_font: اگر فارسی است، فونت فارسی تنظیم شود
            if (styleApi === 'text_font' && hasPersianText) {
                code.push(`    styleModule.set_style_text_font(${id}, lv.lvgl_style_get_persian_font("persian_16"));`);
            } 
            // اگر style مربوط به PART خاصی است (مثل MAIN.text_color)
            else if (styleApi.includes('.')) {
                // فقط قسمت بعد از نقطه را بگیر (text_color)
                const cleanApi = styleApi.split('.')[1];
                code.push(`    styleModule.set_style_${cleanApi}(${id}, ${formattedValue});`);
            } else {
                code.push(`    styleModule.set_style_${styleApi}(${id}, ${formattedValue});`);
            }
        }
    }
    
    return code.length > 0 ? '\n' + code.join('\n') : '';
}

// ==================== توابع کمکی ====================
function getEVMCreateFunction(type) {
    const typeMap = {
        'obj': 'lv_obj_create',
        'btn': 'lv_btn_create',
        'label': 'lv_label_create',
        'arc': 'lv_arc_create',
        'img': 'lv_img_create',
        'slider': 'lv_slider_create',
        'switch': 'lv_switch_create',
        'checkbox': 'lv_checkbox_create',
        'textarea': 'lv_textarea_create',
        'dropdown': 'lv_dropdown_create',
    };
    return typeMap[type] || 'lv_obj_create';
}

function getEVMSetterFunction(type, attr) {
    const generalSetters = {
        'x': 'lv_obj_set_x',
        'y': 'lv_obj_set_y',
        'pos': 'lv_obj_set_pos',
        'width': 'lv_obj_set_width',
        'height': 'lv_obj_set_height',
        'size': 'lv_obj_set_size',
    };
    
    if (generalSetters[attr]) {
        return generalSetters[attr];
    }
    
    return `lv_${type}_set_${attr}`;
}

function getEVMApiFunction(type, api) {
    const specialAPIs = {
        'label': {
            'set_text': 'lv_label_set_text',
        },
        'btn': {
            'set_text': 'lv_btn_set_text',
        },
        'arc': {
            'set_value': 'lv_arc_set_value',
            'set_range': 'lv_arc_set_range',
            'set_start_angle': 'lv_arc_set_start_angle',
            'set_end_angle': 'lv_arc_set_end_angle',
            'set_bg_start_angle': 'lv_arc_set_bg_start_angle',
            'set_bg_end_angle': 'lv_arc_set_bg_end_angle',
            'set_mode': 'lv_arc_set_mode',
        },
        'slider': {
            'set_value': 'lv_slider_set_value',
        },
        'checkbox': {
            'set_text': 'lv_checkbox_set_text',
        },
        'textarea': {
            'set_text': 'lv_textarea_set_text',
        },
        'dropdown': {
            'set_options': 'lv_dropdown_set_options',
        },
        'img': {
            'set_src': 'lv_img_set_src',
            'set_angle': 'lv_img_set_angle',
        }
    };
    
    if (specialAPIs[type] && specialAPIs[type][api]) {
        return specialAPIs[type][api];
    }
    
    return `lv_${type}_${api}`;
}

// ==================== فرمت‌بندی ====================
function formatEVMValue(attr, value) {
    if (value === undefined || value === null || value === '') {
        return 'null';
    }
    
    // اگر رشته است
    if (typeof value === 'string') {
        let cleanValue = value;
        if (cleanValue.startsWith('"') && cleanValue.endsWith('"')) {
            cleanValue = cleanValue.slice(1, -1);
        }
        if (cleanValue.startsWith("'") && cleanValue.endsWith("'")) {
            cleanValue = cleanValue.slice(1, -1);
        }
        
        // اگر متن است
        if (attr === 'text' || attr.includes('text') || attr === 'src' || attr === 'options') {
            return `"${cleanValue}"`;
        }
        
        // اگر عدد است
        if (!isNaN(cleanValue) && cleanValue.trim() !== '') {
            return cleanValue;
        }
        
        // اگر boolean است (با حروف کوچک)
        if (cleanValue.toLowerCase() === 'false') return 'false';
        if (cleanValue.toLowerCase() === 'true') return 'true';
        
        return `"${cleanValue}"`;
    }
    
    // اگر عدد است
    if (typeof value === 'number') {
        // اگر رنگ است
        if (attr.includes('color')) {
            return `lv.lv_color_hex(0x${value.toString(16).padStart(6, '0')})`;
        }
        return value;
    }
    
    // اگر boolean است
    if (typeof value === 'boolean') {
        return value ? 'true' : 'false';
    }
    
    return JSON.stringify(value);
}


function formatEVMStyleValue(styleApi, value) {
    if (value === undefined || value === null || value === '') {
        return '0';
    }
    
    // اگر رشته است
    if (typeof value === 'string') {
        let cleanValue = value;
        if (cleanValue.startsWith('"') && cleanValue.endsWith('"')) {
            cleanValue = cleanValue.slice(1, -1);
        }
        if (cleanValue.startsWith("'") && cleanValue.endsWith("'")) {
            cleanValue = cleanValue.slice(1, -1);
        }
        
        // برای font - دو حالت داریم:
        if (styleApi.includes('font')) {
            // حالت 1: font_montserrat_16
            if (cleanValue.includes('font_montserrat')) {
                // عدد سایز را استخراج کن
                const sizeMatch = cleanValue.match(/font_montserrat_(\d+)/);
                if (sizeMatch) {
                    const size = sizeMatch[1];
                    return `lv.lvgl_style_get_font(${size})`;
                }
                return `lv.lvgl_style_get_font(16)`; // پیش‌فرض
            }
            // حالت 2: فقط عدد (مثل 16، 26)
            else if (!isNaN(cleanValue)) {
                return `lv.lvgl_style_get_font(${cleanValue})`;
            }
            // حالت 3: persian font
            else if (cleanValue.includes('persian')) {
                const sizeMatch = cleanValue.match(/persian_(\d+)/);
                if (sizeMatch) {
                    const size = sizeMatch[1];
                    return `lv.lvgl_style_get_persian_font("persian_${size}")`;
                }
                return `lv.lvgl_style_get_persian_font("persian_16")`;
            }
            
            return cleanValue; // بدون تغییر
        }
        
        // برای رنگ‌ها
        if (styleApi.includes('color')) {
            if (cleanValue.startsWith('0x')) {
                return `lv.lv_color_hex(${cleanValue})`;
            }
            if (cleanValue.startsWith('#')) {
                const hex = cleanValue.replace('#', '0x');
                return `lv.lv_color_hex(${hex})`;
            }
            // اگر عدد است
            if (!isNaN(cleanValue)) {
                return `lv.lv_color_hex(0x${parseInt(cleanValue).toString(16).padStart(6, '0')})`;
            }
        }
        
        // برای opa
        if (styleApi.includes('opa')) {
            if (cleanValue === '255' || cleanValue.toLowerCase() === 'cover') {
                return '255';
            }
            if (cleanValue === '0' || cleanValue.toLowerCase() === 'transp') {
                return '0';
            }
        }
        
        // برای boolean
        if (cleanValue.toLowerCase() === 'false') return 'false';
        if (cleanValue.toLowerCase() === 'true') return 'true';
        
        // برای اعداد
        if (!isNaN(cleanValue) && cleanValue.trim() !== '') {
            return cleanValue;
        }
        
        // برای متن
        return `"${cleanValue}"`;
    }
    
    // اگر عدد است
    if (typeof value === 'number') {
        if (styleApi.includes('color')) {
            return `lv.lv_color_hex(0x${value.toString(16).padStart(6, '0')})`;
        }
        return value;
    }
    
    // اگر boolean است
    if (typeof value === 'boolean') {
        return value ? 'true' : 'false';
    }
    
    return JSON.stringify(value);
}



// ==================== توابع کمکی فارسی ====================

// تابع کمکی برای تشخیص حروف فارسی
function containsPersian(text) {
    if (typeof text !== 'string') return false;
    
    // حذف quoteها
    let cleanText = text;
    if (cleanText.startsWith('"') && cleanText.endsWith('"')) {
        cleanText = cleanText.slice(1, -1);
    }
    if (cleanText.startsWith("'") && cleanText.endsWith("'")) {
        cleanText = cleanText.slice(1, -1);
    }
    
    // محدوده Unicode حروف فارسی
    const persianRange = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
    return persianRange.test(cleanText);
}